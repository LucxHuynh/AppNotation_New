<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paint Pro Toolbar</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/konva@9.3.16/konva.min.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            background-color: #eaeaea;
        }

        #toolbar {
            display: flex;
            align-items: center;
            background-color: #f0f0f0;
            padding: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            overflow-x: auto;
            white-space: nowrap;
            border-bottom: 2px solid #999;
        }

        .section {
            display: flex;
            align-items: center;
            margin-right: 20px;
        }

            .section label {
                margin-right: 10px;
                font-size: 14px;
            }

            .section select,
            .section button {
                padding: 5px;
                border: 1px solid #ccc;
                border-radius: 4px;
                font-size: 14px;
                margin-right: 5px;
                cursor: pointer;
            }

                .section button i {
                    font-size: 16px;
                }

                .section button:hover {
                    background-color: #e6e6e6;
                }

        #canvas-wrapper {
            position: relative;
            flex: 1;
            overflow: auto; /* Để hỗ trợ cuộn khi phóng to */
            border: 2px solid #ccc;
            margin: 20px;
            background: #888888;
        }

        #canvas-container {
            width: 1000px;
            height: 600px;
            background-color: white;
            transform-origin: top left; /* Gốc zoom từ góc trên trái */
        }
    </style>
</head>
<body>

    <!-- Toolbar -->
    <div id="toolbar">
        <!-- Select Section -->
        <div class="section">
            <label>Select:</label>
            <select id="selectDropdown" onchange="handleSelectOption(this.value)">
                <option value="">-- Select --</option>
                <option value="rectangle">Rectangle</option>
                <option value="selectall">Select All</option>
                <option value="delete">Delete</option>
            </select>
        </div>

        <!-- Image Section -->
        <div class="section">
            <label>Image:</label>
            <button onclick="saveCanvas()" title="Save"><i class="fas fa-save"></i></button>
            <button onclick="uploadImage()" title="Upload Image"><i class="fas fa-image"></i></button>
        </div>

        <!-- Tools Section -->
        <div class="section">
            <label>Tools:</label>
            <button onclick="setTool('pencil')" title="Pencil"><i class="fas fa-pencil-alt"></i></button>
            <button onclick="setTool('eraser')" title="Eraser"><i class="fas fa-eraser"></i></button>
            <button onclick="setTool('text')" title="Text"><i class="fas fa-font"></i></button>
            <button onclick="setTool('fill')" title="Fill"><i class="fas fa-fill-drip"></i></button>
            <button onclick="setTool('zoom')" title="Zoom"><i class="fas fa-search-plus"></i></button>
        </div>

        <!-- Shapes Section -->
        <div class="section">
            <label>Shapes:</label>
            <select id="shapeDropdown" onchange="selectShape(this.value)">
                <option value="">-- Shapes --</option>
                <option value="line">Line</option>
                <option value="wave">Wave</option>
                <option value="circle">Circle</option>
                <option value="rectangle">Rectangle</option>
                <option value="triangle">Triangle</option>
                <option value="star">Star</option>
                <option value="arrow">Arrow</option>
                <option value="chat">Chat Bubble</option>
            </select>
        </div>

        <!-- Colors Section -->
        <div class="section">
            <label>Colors:</label>
            <input type="color" id="colorPicker" value="#000000" onchange="setColor(this.value)">
            <input type="range" id="brushSize" min="1" max="50" value="5" onchange="setBrushSize(this.value)">
        </div>

        <!-- Undo/Redo Section -->
        <div class="section">
            <button onclick="undoAction()" title="Undo"><i class="fas fa-undo"></i></button>
            <button onclick="redoAction()" title="Redo"><i class="fas fa-redo"></i></button>
        </div>
        <div class="section">
            <button onclick="clearCanvas()" title="Clear Canvas"><i class="fas fa-trash"></i> Clear</button>
        </div>
    </div>

    <!-- Canvas Container -->
    <div id="canvas-wrapper">
        <div id="canvas-container"></div>
    </div>

    <script>
        // Tạo stage Konva
        const container = document.getElementById('canvas-container');
        const wrapper = document.getElementById('canvas-wrapper');
        const stage = new Konva.Stage({
            container: 'canvas-container',
            width: container.offsetWidth,
            height: container.offsetHeight,
        });

        const layer = new Konva.Layer();
        stage.add(layer);

        // Biến toàn cục
        let currentColor = '#000000';
        let brushSize = 5;
        let history = [];
        let redoStack = [];
        let currentTool = null;
        let isDrawing = false;
        let currentLine = null;
        let containerScale = 1; // Tỉ lệ zoom của canvas-container

        // Zoom khung vẽ (canvas-container)
        wrapper.addEventListener('wheel', (e) => {
            e.preventDefault();

            const scaleBy = 0.1;
            if (e.deltaY < 0) {
                // Zoom in
                containerScale += scaleBy;
            } else {
                // Zoom out
                containerScale -= scaleBy;
            }

            // Giới hạn zoom tối thiểu
            containerScale = Math.max(containerScale, 0.5);

            // Cập nhật zoom
            container.style.transform = `scale(${containerScale})`;
            container.style.transformOrigin = 'top left'; // Zoom từ góc trái trên
        });

        // Lưu canvas thành ảnh (không ảnh hưởng đến lịch sử)
        //function saveCanvas() {
        //    const dataURL = stage.toDataURL();
        //    const link = document.createElement('a');
        //    link.download = 'drawing.png';
        //    link.href = dataURL;
        //    link.click();
        //}

        function saveCanvas() {
            const dataURL = stage.toDataURL({
                mimeType: 'image/png',
                quality: 1
            });

            // Gọi native function qua bridge
            if (window.chrome?.webview) {
                // Windows
                window.chrome.webview.postMessage({
                    type: 'saveCanvas',
                    data: dataURL
                });
            } else {
                // Android
                saveCanvasInterface.saveImage(dataURL);
            }
        }

        // Khởi tạo Transformer
        const transformer = new Konva.Transformer({
            resizeEnabled: true,
            rotateEnabled: true,
            anchorStroke: 'blue',
            anchorFill: 'white',
            anchorSize: 10,
        });
        layer.add(transformer);

        // Tải ảnh lên với chức năng chỉnh kích thước
        function uploadImage() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = (event) => {
                const file = event.target.files[0];
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.src = e.target.result;
                    img.onload = () => {
                        const konvaImage = new Konva.Image({
                            x: 50,
                            y: 50,
                            image: img,
                            draggable: true,
                        });

                        layer.add(konvaImage);
                        layer.draw();

                        konvaImage.on('click', () => {
                            transformer.nodes([konvaImage]);
                            layer.draw();
                        });

                        stage.on('click', (e) => {
                            if (e.target === stage) {
                                transformer.nodes([]);
                                layer.draw();
                            }
                        });

                        // Lưu hành động thêm ảnh vào lịch sử
                        addToHistory({
                            type: 'add',
                            object: konvaImage,
                        });
                    };
                };
                reader.readAsDataURL(file);
            };
            input.click();
        }

        // Công cụ Pencil
        stage.on('mousedown', () => {
            if (currentTool === 'pencil') {
                isDrawing = true;
                const pos = stage.getPointerPosition();
                currentLine = new Konva.Line({
                    stroke: currentColor,
                    strokeWidth: brushSize,
                    points: [pos.x, pos.y],
                    lineCap: 'round',
                    lineJoin: 'round',
                    draggable: false,
                });
                layer.add(currentLine);
            }
        });

        stage.on('mousemove', () => {
            if (isDrawing && currentTool === 'pencil') {
                const pos = stage.getPointerPosition();
                const points = currentLine.points().concat([pos.x, pos.y]);
                currentLine.points(points);
                layer.batchDraw();
            }
        });

        stage.on('mouseup', () => {
            if (isDrawing && currentTool === 'pencil') {
                isDrawing = false;

                // Lưu hành động vẽ vào lịch sử
                addToHistory({
                    type: 'add',
                    object: currentLine,
                });
            }
        });

        // Công cụ Eraser
        stage.on('click', (e) => {
            if (currentTool === 'eraser' && e.target !== stage) {
                e.target.destroy();
                history.push(() => layer.add(e.target));
                layer.batchDraw();
            }
        });

        // Công cụ Text
        function addText() {
            if (currentTool === 'text') {
                const pos = stage.getPointerPosition();
                const textNode = new Konva.Text({
                    x: pos.x,
                    y: pos.y,
                    text: 'Double click to edit',
                    fontSize: 16,
                    fontFamily: 'Arial',
                    fill: currentColor,
                    draggable: true,
                });
                layer.add(textNode);
                layer.draw();

                // Lưu hành động thêm text vào lịch sử
                addToHistory({
                    type: 'add',
                    object: textNode,
                });

                textNode.on('dblclick', () => {
                    const textPosition = textNode.absolutePosition();
                    const stageBox = stage.container().getBoundingClientRect();

                    const textarea = document.createElement('textarea');
                    document.body.appendChild(textarea);

                    textarea.value = textNode.text();
                    textarea.style.position = 'absolute';
                    textarea.style.top = `${textPosition.y + stageBox.top}px`;
                    textarea.style.left = `${textPosition.x + stageBox.left}px`;
                    textarea.style.width = `${textNode.width() - textNode.padding() * 2}px`;
                    textarea.style.height = `${textNode.height() - textNode.padding() * 2}px`;
                    textarea.style.border = 'none';
                    textarea.style.padding = '50px';
                    textarea.style.margin = '50px';
                    textarea.style.overflow = 'hidden';
                    textarea.style.background = 'none';
                    textarea.style.outline = 'none';
                    textarea.style.resize = 'none';
                    textarea.style.lineHeight = `${textNode.lineHeight()}`;
                    textarea.style.fontFamily = textNode.fontFamily();
                    textarea.style.transformOrigin = 'left top';
                    textarea.style.textAlign = textNode.align();
                    textarea.style.color = textNode.fill();
                    textarea.focus();

                    textarea.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            // Lưu trạng thái cũ và mới để Undo/Redo
                            addToHistory({
                                type: 'update',
                                object: textNode,
                                oldAttrs: { text: textNode.text() },
                                newAttrs: { text: textarea.value },
                            });

                            textNode.text(textarea.value);
                            layer.draw();
                            document.body.removeChild(textarea);
                        }
                    });

                    textarea.addEventListener('blur', () => {
                        textNode.text(textarea.value);
                        layer.draw();
                        document.body.removeChild(textarea);
                    });
                });
            }
        }

        // Công cụ Fill
        stage.on('click', (e) => {
            if (currentTool === 'fill' && e.target !== stage) {
                const target = e.target;
                if (target.fill) {
                    // Lưu trạng thái cũ và mới để Undo/Redo
                    const oldFill = target.fill();
                    addToHistory({
                        type: 'update',
                        object: target,
                        oldAttrs: { fill: oldFill },
                        newAttrs: { fill: currentColor },
                    });

                    // Đặt màu cho đối tượng
                    target.fill(currentColor);
                    layer.batchDraw();
                } else {
                    console.warn('Object does not support fill property.');
                }
            }
        });

        // Lưu trạng thái của hình vẽ
        let tempShape = null; // Lưu trữ hình đang vẽ
        let startPos = null; // Vị trí bắt đầu

        // Bắt đầu vẽ
        stage.on('mousedown touchstart', (e) => {
            if (!currentTool || e.target !== stage) return; // Không vẽ nếu không chọn công cụ hoặc nhấn vào đối tượng

            const pointerPos = stage.getPointerPosition();
            startPos = { x: pointerPos.x, y: pointerPos.y };
            isDrawing = true;

            const shapeOptions = {
                stroke: currentColor,
                strokeWidth: 2,
                draggable: true,
            };

            switch (currentTool) {
                case 'line':
                case 'arrow':
                    tempShape =
                        currentTool === 'line'
                            ? new Konva.Line({
                                ...shapeOptions,
                                points: [startPos.x, startPos.y, startPos.x, startPos.y],
                            })
                            : new Konva.Arrow({
                                ...shapeOptions,
                                points: [startPos.x, startPos.y, startPos.x, startPos.y],
                                pointerLength: 10,
                                pointerWidth: 10,
                            });
                    break;
                case 'rectangle':
                    tempShape = new Konva.Rect({
                        ...shapeOptions,
                        x: startPos.x,
                        y: startPos.y,
                        width: 0,
                        height: 0,
                    });
                    break;
                case 'circle':
                    tempShape = new Konva.Circle({
                        ...shapeOptions,
                        x: startPos.x,
                        y: startPos.y,
                        radius: 0,
                    });
                    break;
                case 'triangle':
                    tempShape = new Konva.Line({
                        ...shapeOptions,
                        points: [startPos.x, startPos.y, startPos.x, startPos.y, startPos.x, startPos.y],
                        closed: true,
                    });
                    break;
                case 'wave':
                    tempShape = new Konva.Line({
                        ...shapeOptions,
                        points: [startPos.x, startPos.y, startPos.x, startPos.y, startPos.x, startPos.y],
                        tension: 0.5,
                    });
                    break;
                case 'star':
                    tempShape = new Konva.Star({
                        ...shapeOptions,
                        x: startPos.x,
                        y: startPos.y,
                        numPoints: 5,
                        innerRadius: 0,
                        outerRadius: 0,
                    });
                    break;
                case 'chat':
                    tempShape = new Konva.Path({
                        ...shapeOptions,
                        data: 'M10 10 C 20 10, 40 10, 50 50 Q 60 80, 80 50 T 150 10',
                        scaleX: 1,
                        scaleY: 1,
                    });
                    tempShape.x(startPos.x);
                    tempShape.y(startPos.y);
                    break;
                default:
                    console.log('Invalid tool selected.');
                    return;
            }

            if (tempShape) {
                layer.add(tempShape);
            }
        });

        // Khi kéo chuột để thay đổi hình dạng
        stage.on('mousemove touchmove', (e) => {
            if (!tempShape || !isDrawing) return;

            const pointerPos = stage.getPointerPosition();

            switch (currentTool) {
                case 'line':
                case 'arrow':
                    tempShape.points([startPos.x, startPos.y, pointerPos.x, pointerPos.y]);
                    break;
                case 'rectangle':
                    tempShape.width(Math.abs(pointerPos.x - startPos.x));
                    tempShape.height(Math.abs(pointerPos.y - startPos.y));
                    tempShape.x(Math.min(startPos.x, pointerPos.x));
                    tempShape.y(Math.min(startPos.y, pointerPos.y));
                    break;
                case 'circle':
                    const radius = Math.sqrt(Math.pow(pointerPos.x - startPos.x, 2) + Math.pow(pointerPos.y - startPos.y, 2));
                    tempShape.radius(radius);
                    break;
                case 'triangle':
                    tempShape.points([
                        startPos.x,
                        startPos.y,
                        pointerPos.x,
                        pointerPos.y,
                        startPos.x - (pointerPos.x - startPos.x),
                        pointerPos.y,
                    ]);
                    break;
                case 'wave':
                    const midX = (startPos.x + pointerPos.x) / 2;
                    const midY = (startPos.y + pointerPos.y) / 2 - 50;
                    tempShape.points([startPos.x, startPos.y, midX, midY, pointerPos.x, pointerPos.y]);
                    break;
                case 'star':
                    const distance = Math.sqrt(Math.pow(pointerPos.x - startPos.x, 2) + Math.pow(pointerPos.y - startPos.y, 2));
                    tempShape.innerRadius(distance / 2);
                    tempShape.outerRadius(distance);
                    break;
                case 'chat':
                    tempShape.scaleX((pointerPos.x - startPos.x) / 150);
                    tempShape.scaleY((pointerPos.y - startPos.y) / 100);
                    break;
            }

            layer.batchDraw();
        });

        // Khi nhả chuột
        stage.on('mouseup touchend', () => {
            if (isDrawing) {
                isDrawing = false;

                if (tempShape) {
                    // Thêm Transformer nếu cần
                    if (['rectangle', 'circle', 'triangle', 'star', 'line', 'arrow', 'wave'].includes(currentTool)) {
                        transformer.nodes([tempShape]);
                    }

                    if (['line', 'arrow', 'wave'].includes(currentTool)) {
                        addResizeHandles(tempShape);
                    }

                    // Lưu hành động vào lịch sử
                    addToHistory({
                        type: 'add',
                        object: tempShape,
                    });

                    tempShape = null;
                }
            }
        });

        // Xóa nốt hoặc transformer khi đổi công cụ
        function clearTransformers() {
            transformer.nodes([]);
            layer.draw();
        }


        // Biến toàn cục để lưu trữ nốt hiện tại
        let activeHandles = [];

        // Hàm xóa nốt khi chuyển công cụ hoặc sử dụng công cụ khác
        function clearHandles() {
            activeHandles.forEach((handle) => handle.destroy());
            activeHandles = [];
            layer.batchDraw();
        }
        // Hàm xóa tất cả các nốt (handles) và transformer khi chuyển công cụ hoặc sử dụng công cụ khác
        function clearHandlesAndTransformers() {
            // Xóa nốt chỉnh sửa
            activeHandles.forEach((handle) => handle.destroy());
            activeHandles = [];

            // Xóa Transformer
            transformer.nodes([]); // Đảm bảo không có node nào được chọn
            layer.batchDraw();
        }

        // Kích hoạt công cụ
        function setTool(tool) {
            clearHandles(); // Xóa nốt khi chuyển công cụ
            clearHandlesAndTransformers(); // Xóa tất cả nốt và Transformer
            currentTool = tool;

            // Xử lý công cụ text
            if (tool === 'text') addText();

            console.log(`Tool selected: ${tool}`);
        }

        // Hàm thêm nốt điều chỉnh cho Line, Arrow, Wave
        function addResizeHandles(shape) {
            clearHandles(); // Xóa nốt cũ khi vẽ hình mới

            const points = shape.points();

            // Nốt bắt đầu
            const startHandle = new Konva.Circle({
                x: points[0],
                y: points[1],
                radius: 5,
                fill: 'blue',
                draggable: true,
            });

            // Nốt kết thúc
            const endHandle = new Konva.Circle({
                x: points[2],
                y: points[3],
                radius: 5,
                fill: 'blue',
                draggable: true,
            });

            // Cập nhật vị trí Line/Arrow/Wave khi kéo nốt bắt đầu
            startHandle.on('dragmove', () => {
                const newPoints = [startHandle.x(), startHandle.y(), endHandle.x(), endHandle.y()];
                shape.points(newPoints);
                layer.batchDraw();
            });

            // Cập nhật vị trí Line/Arrow/Wave khi kéo nốt kết thúc
            endHandle.on('dragmove', () => {
                const newPoints = [startHandle.x(), startHandle.y(), endHandle.x(), endHandle.y()];
                shape.points(newPoints);
                layer.batchDraw();
            });

            // Đồng bộ hóa nốt khi đối tượng được di chuyển
            shape.on('dragmove', () => {
                const updatedPoints = shape.points();
                startHandle.position({ x: updatedPoints[0], y: updatedPoints[1] });
                endHandle.position({ x: updatedPoints[2], y: updatedPoints[3] });
                layer.batchDraw();
            });

            // Thêm nốt vào danh sách quản lý
            activeHandles.push(startHandle, endHandle);

            // Thêm các nốt vào layer
            layer.add(startHandle, endHandle);
            layer.batchDraw();
        }

        // Hàm vẽ Line, Arrow, Wave
        function drawLineShape(type) {
            clearHandles(); // Xóa nốt khi bắt đầu vẽ mới

            let shape;
            const startPoint = { x: null, y: null };

            stage.on('mousedown', (e) => {
                if (currentTool === 'shapes' && type && !isDrawing) {
                    isDrawing = true;
                    const pos = stage.getPointerPosition();
                    startPoint.x = pos.x;
                    startPoint.y = pos.y;

                    // Tạo hình
                    if (type === 'line') {
                        shape = new Konva.Line({
                            points: [startPoint.x, startPoint.y, startPoint.x, startPoint.y],
                            stroke: currentColor,
                            strokeWidth: brushSize,
                            lineCap: 'round',
                            draggable: true,
                        });
                    } else if (type === 'arrow') {
                        shape = new Konva.Arrow({
                            points: [startPoint.x, startPoint.y, startPoint.x, startPoint.y],
                            stroke: currentColor,
                            strokeWidth: brushSize,
                            pointerWidth: 10,
                            pointerLength: 15,
                            draggable: true,
                        });
                    } else if (type === 'wave') {
                        shape = new Konva.Line({
                            points: [startPoint.x, startPoint.y, startPoint.x, startPoint.y],
                            stroke: currentColor,
                            strokeWidth: brushSize,
                            lineJoin: 'round',
                            tension: 0.5,
                            draggable: true,
                        });
                    }

                    layer.add(shape);
                    layer.batchDraw();
                }
            });

            stage.on('mousemove', (e) => {
                if (isDrawing && shape) {
                    const pos = stage.getPointerPosition();
                    shape.points([startPoint.x, startPoint.y, pos.x, pos.y]);
                    layer.batchDraw();
                }
            });

            stage.on('mouseup', () => {
                if (isDrawing) {
                    isDrawing = false;

                    // Thêm nốt chỉnh sửa cho Line, Arrow, Wave
                    addResizeHandles(shape);

                    // Lưu vào lịch sử để hỗ trợ Undo
                    history.push(() => shape.destroy());
                }
            });
        }

        // Lựa chọn hình dạng
        function selectShape(shapeType) {
            clearHandles(); // Xóa nốt khi vẽ hình mới hoặc chuyển công cụ

            if (['line', 'arrow', 'wave', 'circle', 'rectangle', 'triangle', 'star', 'chat'].includes(shapeType)) {
                drawLineShape(shapeType);
            }

            console.log(`Shape selected: ${shapeType}`);
        }



        // Ngăn tạo hình khi kéo thả hoặc chỉnh sửa
        stage.on('dragstart', () => {
            isDrawing = false;
        });

        // Hàm chọn công cụ Shape
        function selectShape(shape) {
            currentTool = shape;
            console.log(`Shape selected: ${shape}`);
        }


        // Hàm lưu hành động vào lịch sử
        function addToHistory(action) {
            history.push(action);
            redoStack = []; // Xóa redoStack khi có hành động mới
        }

        // Hàm Undo
        function undoAction() {
            if (history.length > 0) {
                const lastAction = history.pop();
                redoStack.push(lastAction);

                if (lastAction.type === 'add') {
                    // Nếu hành động là thêm, xóa đối tượng
                    lastAction.object.destroy();
                } else if (lastAction.type === 'remove') {
                    // Nếu hành động là xóa, thêm lại đối tượng
                    layer.add(lastAction.object);
                } else if (lastAction.type === 'update') {
                    // Nếu hành động là cập nhật, khôi phục trạng thái cũ
                    lastAction.object.setAttrs(lastAction.oldAttrs);
                }

                layer.batchDraw();
            }
        }

        // Hàm Redo
        function redoAction() {
            if (redoStack.length > 0) {
                const lastRedo = redoStack.pop();
                history.push(lastRedo);

                if (lastRedo.type === 'add') {
                    // Nếu hành động là thêm, thêm lại đối tượng
                    layer.add(lastRedo.object);
                } else if (lastRedo.type === 'remove') {
                    // Nếu hành động là xóa, xóa đối tượng
                    lastRedo.object.destroy();
                } else if (lastRedo.type === 'update') {
                    // Nếu hành động là cập nhật, áp dụng trạng thái mới
                    lastRedo.object.setAttrs(lastRedo.newAttrs);
                }

                layer.batchDraw();
            }
        }
        function clearCanvas() {
            if (confirm('Bạn muốn xoá toàn bộ canvas? Thao tác này không thể khôi phục khi thực hiện')) {
                // Nội dung hàm clearCanvas()
                // Lặp qua tất cả các con của layer và xóa chúng
                layer.destroyChildren();

                // Xóa các transformer và nốt (nếu có)
                transformer.nodes([]);
                activeHandles.forEach((handle) => handle.destroy());
                activeHandles = [];

                // Làm sạch canvas
                layer.batchDraw();

                // Làm sạch lịch sử undo/redo
                history = [];
                redoStack = [];

                console.log('Canvas cleared successfully.');
            }
        }

        // Chọn màu
        function setColor(color) {
            currentColor = color;
        }

        // Chọn kích thước cọ
        function setBrushSize(size) {
            brushSize = size;
        }

        // Hàm lấy nội dung vẽ để lưu
        function getEditorContent() {
            const data = {
                stage: {
                    width: stage.width(),
                    height: stage.height(),
                    scaleX: stage.scaleX(),
                    scaleY: stage.scaleY(),
                    x: stage.x(),
                    y: stage.y()
                },
                shapes: layer.children.map(shape => {
                    const baseAttrs = {
                        stroke: shape.attrs.stroke || '#000000',
                        strokeWidth: shape.attrs.strokeWidth || 2,
                        draggable: shape.attrs.draggable || false,
                        ...shape.attrs
                    };

                    // Tùy chỉnh attrs dựa vào loại shape
                    switch (shape.getClassName()) {
                        case 'Line':
                            return {
                                className: 'Line',
                                attrs: {
                                    ...baseAttrs,
                                    points: shape.points(),
                                    lineCap: shape.attrs.lineCap || 'round',
                                    lineJoin: shape.attrs.lineJoin || 'round'
                                },
                                id: shape.id()
                            };
                        case 'Star':
                            return {
                                className: 'Star',
                                attrs: {
                                    ...baseAttrs,
                                    x: shape.x(),
                                    y: shape.y(),
                                    numPoints: shape.attrs.numPoints || 5,
                                    innerRadius: shape.attrs.innerRadius,
                                    outerRadius: shape.attrs.outerRadius
                                },
                                id: shape.id()
                            };
                        case 'Circle':
                            return {
                                className: 'Circle',
                                attrs: {
                                    ...baseAttrs,
                                    x: shape.x(),
                                    y: shape.y(),
                                    radius: shape.radius()
                                },
                                id: shape.id()
                            };
                        case 'Rect':
                            return {
                                className: 'Rect',
                                attrs: {
                                    ...baseAttrs,
                                    x: shape.x(),
                                    y: shape.y(),
                                    width: shape.width(),
                                    height: shape.height()
                                },
                                id: shape.id()
                            };
                        case 'Transformer':
                            return {
                                className: 'Transformer',
                                attrs: {
                                    resizeEnabled: true,
                                    rotateEnabled: true,
                                    anchorStroke: 'blue',
                                    anchorFill: 'white',
                                    anchorSize: 10,
                                    ...baseAttrs
                                },
                                id: shape.id()
                            };
                        default:
                            return {
                                className: shape.getClassName(),
                                attrs: baseAttrs,
                                id: shape.id()
                            };
                    }
                })
            };

            return JSON.stringify(data);
        }

        // Hàm khôi phục nội dung vẽ
        function setEditorContent(content) {
            if (!content) return;

            try {
                // Xử lý chuỗi JSON - loại bỏ escape characters dư thừa
                content = content.replace(/\\\"/g, '"');
                const data = JSON.parse(content);

                // Khôi phục stage properties
                if (data.stage) {
                    stage.width(data.stage.width);
                    stage.height(data.stage.height);
                    stage.scale({ x: data.stage.scaleX, y: data.stage.scaleY });
                    stage.position({ x: data.stage.x, y: data.stage.y });
                }

                // Xóa các shapes hiện tại
                layer.destroyChildren();

                // Khôi phục shapes
                data.shapes.forEach(shapeData => {
                    let shape;

                    switch (shapeData.className) {
                        case 'Line':
                            shape = new Konva.Line({
                                ...shapeData.attrs,
                                points: shapeData.attrs.points
                            });
                            break;

                        case 'Star':
                            shape = new Konva.Star({
                                ...shapeData.attrs,
                                numPoints: shapeData.attrs.numPoints || 5,
                                innerRadius: shapeData.attrs.innerRadius,
                                outerRadius: shapeData.attrs.outerRadius
                            });
                            break;

                        case 'Circle':
                            shape = new Konva.Circle({
                                ...shapeData.attrs,
                                radius: shapeData.attrs.radius
                            });
                            break;

                        case 'Rect':
                            shape = new Konva.Rect({
                                ...shapeData.attrs,
                                width: shapeData.attrs.width,
                                height: shapeData.attrs.height
                            });
                            break;

                        case 'Transformer':
                            shape = new Konva.Transformer({
                                resizeEnabled: true,
                                rotateEnabled: true,
                                anchorStroke: 'blue',
                                anchorFill: 'white',
                                anchorSize: 10,
                                ...shapeData.attrs
                            });
                            break;
                    }

                    if (shape) {
                        // Thêm ID nếu có
                        if (shapeData.id) {
                            shape.id(shapeData.id);
                        }

                        // Thêm các event listeners
                        addShapeEventListeners(shape);

                        // Thêm vào layer
                        layer.add(shape);
                    }
                });

                // Cập nhật layer
                layer.draw();

            } catch (error) {
                console.error('Error loading editor content:', error);
            }
        }

        function addShapeEventListeners(shape) {
            // Bỏ qua nếu shape là transformer
            if (shape.getClassName() === 'Transformer') return;

            // Mouseenter - Hiển thị con trỏ pointer
            shape.on('mouseenter', () => {
                stage.container().style.cursor = 'pointer';
                // Highlight shape khi hover
                shape.strokeWidth(shape.strokeWidth() * 1.5);
                layer.draw();
            });

            // Mouseleave - Trả về con trỏ mặc định
            shape.on('mouseleave', () => {
                stage.container().style.cursor = 'default';
                // Bỏ highlight
                shape.strokeWidth(shape.strokeWidth() / 1.5);
                layer.draw();
            });

            // Click - Chọn shape và hiển thị transformer
            shape.on('click tap', (e) => {
                // Ngăn sự kiện nổi bọt
                e.cancelBubble = true;

                // Xóa tất cả transformer hiện có
                stage.find('Transformer').destroy();

                // Set shape được chọn
                selectedShape = shape;

                // Tạo transformer mới
                const tr = new Konva.Transformer({
                    nodes: [shape],
                    // Cấu hình transformer
                    resizeEnabled: true,
                    rotateEnabled: true,
                    // Style cho transformer
                    padding: 5,
                    anchorStroke: 'blue',
                    anchorFill: 'white',
                    anchorSize: 10,
                    borderStroke: 'blue',
                    borderDash: [3, 3],
                    // Các điểm điều chỉnh
                    enabledAnchors: [
                        'top-left',
                        'top-center',
                        'top-right',
                        'middle-right',
                        'middle-left',
                        'bottom-left',
                        'bottom-center',
                        'bottom-right'
                    ]
                });

                // Thêm transformer vào layer
                layer.add(tr);
                layer.draw();
            });

            // Double click để chỉnh sửa text (nếu là text shape)
            if (shape.getClassName() === 'Text') {
                shape.on('dblclick dbltap', () => {
                    // Tạo textarea
                    const textPosition = shape.absolutePosition();
                    const areaPosition = {
                        x: textPosition.x,
                        y: textPosition.y
                    };

                    const textarea = document.createElement('textarea');
                    document.body.appendChild(textarea);

                    textarea.value = shape.text();
                    textarea.style.position = 'absolute';
                    textarea.style.top = areaPosition.y + 'px';
                    textarea.style.left = areaPosition.x + 'px';
                    textarea.style.width = shape.width() + 'px';

                    textarea.focus();

                    textarea.addEventListener('blur', function () {
                        shape.text(textarea.value);
                        document.body.removeChild(textarea);
                        layer.draw();
                    });
                });
            }

            // Thêm các tính năng kéo thả
            if (shape.draggable()) {
                // Bắt đầu kéo
                shape.on('dragstart', () => {
                    shape.moveToTop();
                    layer.draw();
                });

                // Đang kéo
                shape.on('dragmove', () => {
                    // Cập nhật vị trí của transformer nếu có
                    layer.draw();
                });

                // Kết thúc kéo
                shape.on('dragend', () => {
                    layer.draw();
                });
            }

            // Xử lý transform
            shape.on('transform', () => {
                // Xử lý đặc biệt cho từng loại shape
                switch (shape.getClassName()) {
                    case 'Text':
                        // Cập nhật font size khi resize
                        const scaleX = shape.scaleX();
                        shape.setAttrs({
                            width: shape.width() * scaleX,
                            scaleX: 1
                        });
                        break;

                    case 'Star':
                        // Giữ tỷ lệ khi resize
                        const scale = shape.scaleX();
                        shape.setAttrs({
                            innerRadius: shape.innerRadius() * scale,
                            outerRadius: shape.outerRadius() * scale,
                            scaleX: 1,
                            scaleY: 1
                        });
                        break;

                    case 'Circle':
                        // Cập nhật radius khi resize
                        const newRadius = shape.width() / 2 * shape.scaleX();
                        shape.setAttrs({
                            radius: newRadius,
                            scaleX: 1,
                            scaleY: 1
                        });
                        break;
                }
            });

            // Xử lý select/deselect
            stage.on('click tap', (e) => {
                // Click vào vùng trống
                if (e.target === stage) {
                    selectedShape = null;
                    // Xóa transformer
                    stage.find('Transformer').destroy();
                    layer.draw();
                }
            });

            // Xử lý xóa shape (Delete key)
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Delete' && selectedShape === shape) {
                    shape.destroy();
                    stage.find('Transformer').destroy();
                    selectedShape = null;
                    layer.draw();
                }
            });
        }

    </script>

</body>
</html>
